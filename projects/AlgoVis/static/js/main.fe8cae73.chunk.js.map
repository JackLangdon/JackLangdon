{"version":3,"sources":["sorting-visualizer/SortingVisualizer.jsx","index.jsx"],"names":["SortingVisualizer","props","newArray","array","i","state","NUM_OF_BARS","push","ranNum","setState","message","Math","floor","random","updateDOM","stepArray","stepCounter","count","runningCount","setTimeout","STEP_SPEED","updateDOMMerge","length","bubbleSort","map","value","j","temp","tempArray","k","insertionSort","selectionSort","biggest","shellSort","inner","outer","interval","steps","this","className","index","key","style","height","width","marginLeft","onClick","React","Component","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.fe8cae73.chunk.js","sourcesContent":["import React from 'react';\nimport './SortingVisualizer.css';\n\nclass SortingVisualizer extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      array: [],\n      message: '',\n      STEP_SPEED: 20,\n      NUM_OF_BARS: 50,\n      tempArray: [],\n      steps: 0,\n    };\n  }\n\n  componentDidMount() {\n    this.newArray();\n  }\n\n  newArray = () => {\n    const array = [];\n\n    for (let i = 0; i < 800; i += 800 / this.state.NUM_OF_BARS) {\n      array.push(this.ranNum());\n    }\n\n    this.setState({\n      array: array,\n      message: 'Choose an algorithm to sort with!',\n    });\n  };\n\n  ranNum = () => {\n    return Math.floor(Math.random() * 490 + 11);\n  };\n\n  updateDOM = (stepArray, stepCounter, count) => {\n    let runningCount = count;\n\n    if (count < stepCounter) {\n      setTimeout(() => {\n        this.setState({ array: stepArray[count] });\n        runningCount++;\n        this.updateDOM(stepArray, stepCounter, runningCount);\n      }, this.state.STEP_SPEED);\n    } else {\n      this.setState({\n        message: `Sort complete! Reset Array and try another algorithm!`,\n      });\n    }\n  };\n\n  updateDOMMerge = (stepArray, count) => {\n    let runningCount = count;\n\n    if (count < stepArray.length) {\n      setTimeout(() => {\n        this.setState({ array: stepArray[count] });\n        runningCount++;\n        this.updateDOMMerge(stepArray, runningCount);\n      }, this.state.STEP_SPEED);\n    } else {\n      this.setState({\n        message: `Sort complete! Reset Array and try another algorithm!`,\n      });\n    }\n  };\n\n  bubbleSort = () => {\n    this.setState({ message: 'Bubble Sorting!' });\n    let newArray = this.state.array.map((value) => {\n      return value;\n    });\n    let stepArray = [];\n    let stepCounter = 0;\n    let count = 0;\n\n    for (let i = 0; i < newArray.length; i++) {\n      for (let j = newArray.length; j >= i; j--) {\n        if (newArray[j] < newArray[j + 1]) {\n          let temp = newArray[j];\n          newArray[j] = newArray[j + 1];\n          newArray[j + 1] = temp;\n\n          // Later algorithms use newArray.map() method to push each update to the step array. This is essentially the same but more concise.\n          let tempArray = [];\n          for (let k = 0; k < newArray.length; k++) {\n            tempArray.push(newArray[k]);\n          }\n          stepArray.push(tempArray);\n\n          // Increment step counter\n          stepCounter++;\n        }\n      }\n    }\n\n    this.updateDOM(stepArray, stepCounter, count);\n  };\n\n  insertionSort = () => {\n    this.setState({ message: 'Insertion Sorting!' });\n    let newArray = this.state.array.map((value) => {\n      return value;\n    });\n    let stepArray = [];\n    let stepCounter = 0;\n    let count = 0;\n\n    for (let i = 0; i < newArray.length; i++) {\n      // INNER FOR-LOOP VERSION\n      // for (let j = i; j > 0; j--) {\n      //   if (j > 0 && newArray[j] > newArray[j - 1]) {\n      //     let temp = newArray[j];\n      //     newArray[j] = newArray[j - 1];\n      //     newArray[j - 1] = temp;\n      //     // Build tempArray from current newArray\n      //     let tempArray = [];\n      //     for (let k = 0; k < newArray.length; k++) {\n      //       tempArray.push(newArray[k]);\n      //     }\n      //     stepArray.push(tempArray);\n      //     // // PUSH NEW ARRAY TO STEP ARRAY\n      //     stepCounter++;\n      //   }\n      // }\n\n      // INNER WHILE-LOOP VERSION\n      let j = i;\n      while (j >= 0 && newArray[j] > newArray[j - 1]) {\n        let temp = newArray[j];\n        newArray[j] = newArray[j - 1];\n        newArray[j - 1] = temp;\n\n        // Update step array\n        stepArray.push(\n          newArray.map((value) => {\n            return value;\n          })\n        );\n\n        // Increment step counter\n        stepCounter++;\n        j--;\n      }\n    }\n\n    this.updateDOM(stepArray, stepCounter, count);\n  };\n\n  selectionSort = () => {\n    this.setState({ message: 'Selection Sorting!' });\n    let newArray = this.state.array.map((value) => {\n      return value;\n    });\n    let stepArray = [];\n    let stepCounter = 0;\n    let count = 0;\n\n    for (let i = 0; i < newArray.length; i++) {\n      let biggest = i;\n      for (let j = i; j < newArray.length; j++) {\n        if (newArray[j] > newArray[biggest]) {\n          biggest = j;\n        }\n      }\n\n      let temp = newArray[i];\n      newArray[i] = newArray[biggest];\n      newArray[biggest] = temp;\n\n      // Update step array\n      stepArray.push(\n        newArray.map((value) => {\n          return value;\n        })\n      );\n\n      // Increment step counter\n      stepCounter++;\n    }\n\n    this.updateDOM(stepArray, stepCounter, count);\n  };\n\n  shellSort = () => {\n    this.setState({ message: 'Shell Sorting!' });\n    let newArray = this.state.array.map((value) => {\n      return value;\n    });\n    let stepArray = [];\n    let stepCounter = 0;\n    let count = 0;\n\n    let inner, outer, temp;\n    let interval = 1;\n\n    while (interval <= newArray.length / 3) {\n      interval = interval * 3 + 1;\n    }\n    while (interval > 0) {\n      for (outer = interval; outer < newArray.length; outer++) {\n        temp = newArray[outer];\n\n        inner = outer;\n\n        while (inner > interval - 1 && newArray[inner - interval] < temp) {\n          newArray[inner] = newArray[inner - interval];\n\n          inner -= interval;\n\n          // Increment step counter\n          stepCounter++;\n\n          // Update step array\n          stepArray.push(\n            newArray.map((value) => {\n              return value;\n            })\n          );\n        }\n\n        newArray[inner] = temp;\n\n        // Increment step counter\n        stepCounter++;\n\n        // Update step array\n        stepArray.push(\n          newArray.map((value) => {\n            return value;\n          })\n        );\n      }\n\n      interval = (interval - 1) / 3;\n    }\n    this.updateDOM(stepArray, stepCounter, count);\n  };\n\n  render() {\n    const { array } = this.state;\n\n    return (\n      <div>\n        <div className=\"bar-container\">\n          {array.map((value, index) => (\n            <div\n              className=\"bar\"\n              key={`${index}`}\n              style={{\n                height: `${value}px`,\n                width: `${800 / this.state.NUM_OF_BARS - 2}px`,\n                marginLeft: `${index * (800 / this.state.NUM_OF_BARS)}px`,\n              }}\n            ></div>\n          ))}\n        </div>\n        <div className=\"button-container\">\n          <button onClick={() => this.newArray()}>Reset Array</button>\n          <button onClick={() => this.bubbleSort()}>Bubble Sort</button>\n          <button onClick={() => this.insertionSort()}>Insertion Sort</button>\n          <button onClick={() => this.selectionSort()}>Selection Sort</button>\n          <button onClick={() => this.shellSort()}>Shell Sort</button>\n        </div>\n        <div className=\"message-container\">{this.state.message}</div>\n      </div>\n    );\n  }\n}\n\nexport default SortingVisualizer;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport SortingVisualizer from './sorting-visualizer/SortingVisualizer';\n\nReactDOM.render(\n  <React.StrictMode>\n    <SortingVisualizer />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}